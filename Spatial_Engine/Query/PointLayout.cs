/*
 * This file is part of the Buildings and Habitats object Model (BHoM)
 * Copyright (c) 2015 - 2020, the respective contributors. All rights reserved.
 *
 * Each contributor holds copyright over their respective contributions.
 * The project versioning (Git) records all such contribution source information.
 *                                           
 *                                                                              
 * The BHoM is free software: you can redistribute it and/or modify         
 * it under the terms of the GNU Lesser General Public License as published by  
 * the Free Software Foundation, either version 3.0 of the License, or          
 * (at your option) any later version.                                          
 *                                                                              
 * The BHoM is distributed in the hope that it will be useful,              
 * but WITHOUT ANY WARRANTY; without even the implied warranty of               
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                 
 * GNU Lesser General Public License for more details.                          
 *                                                                            
 * You should have received a copy of the GNU Lesser General Public License     
 * along with this code. If not, see <https://www.gnu.org/licenses/lgpl-3.0.html>.      
 */

using System;
using System.Linq;
using System.Collections.Generic;
using System.ComponentModel;
using BH.oM.Reflection.Attributes;
using BH.oM.Base;
using BH.oM.Geometry;
using BH.oM.Spatial.Layouts;
using BH.Engine.Geometry;

namespace BH.Engine.Spatial
{
    public static partial class Query
    {
        /***************************************************/
        /**** Public Methods                            ****/
        /***************************************************/

        [Description("Queries the points from the Layout based on the layout and a region curve associated with it.")]
        [Input("layout2D", "The layout object to query the points from.")]
        [Input("hostRegionCurve", "The region curve of the objects associated with the layout.")]
        [Output("points", "Point layout generated by the layout objects and region curve.")]
        public static List<Point> PointLayout(this ExplicitLayout layout2D, ICurve hostRegionCurve)
        {
            return layout2D.Points.ToList();
        }

        /***************************************************/

        [Description("Queries the points from the Layout based on the layout and a region curve associated with it.")]
        [Input("layout2D", "The layout object to query the points from.")]
        [Input("hostRegionCurve", "The region curve of the objects associated with the layout.")]
        [Output("points", "Point layout generated by the layout objects and region curve.")]
        public static List<Point> PointLayout(this PerimiterLayout layout2D, ICurve hostRegionCurve)
        {
            List<ICurve> subCurves = hostRegionCurve.ISubParts().ToList();
            if (layout2D.EnforceDiscontinuityPoints && subCurves.Count != 1)
            {
                List<Point> pts = hostRegionCurve.IDiscontinuityPoints().CullDuplicates();
                int remainingPoints = layout2D.NumberOfPoints - pts.Count;
                if (remainingPoints > 0)
                {
                    
                    List<int> divisions = DistributeDivisions(subCurves, remainingPoints);

                    for (int i = 0; i < subCurves.Count; i++)
                    {
                        if (divisions[i] == 0)
                            continue;

                        int div = divisions[i] + 1; //Add one to make sure point not at end

                        List<Point> subPts = subCurves[i].SamplePoints(div);

                        //Remove points at start/end
                        subPts.RemoveAt(subPts.Count - 1);
                        subPts.RemoveAt(0);
                        pts.AddRange(subPts);
                    }

                }
                pts = pts.ISortAlongCurve(hostRegionCurve);
                return pts;
            }
            else
            {
                return hostRegionCurve.SamplePoints(layout2D.NumberOfPoints - 1);
            }
        }

        /***************************************************/

        [Description("Queries the points from the Layout based on the layout and a region curve associated with it.")]
        [Input("layout2D", "The layout object to query the points from.")]
        [Input("hostRegionCurve", "The region curve of the objects associated with the layout.")]
        [Output("points", "Point layout generated by the layout objects and region curve.")]
        public static List<Point> PointLayout(this LinearLayout layout2D, ICurve hostRegionCurve)
        {
            Point centre = BH.Engine.Geometry.Query.ICentroid(hostRegionCurve);
            centre = centre + layout2D.Offset;
            Line axis = new Line { Start = centre, End = centre + layout2D.Direction, Infinite = true };
            List<Point> interPts = hostRegionCurve.ILineIntersections(axis, true);

            if (interPts.Count < 2)
            {
                Engine.Reflection.Compute.RecordError("Count not find extents of distribution for the layout.");
                return new List<Point>();

            }

            interPts = interPts.SortCollinear().CullDuplicates();

            List<Line> distributionLines = new List<Line>();

            for (int i = 0; i < interPts.Count; i+= 2)
            {
                distributionLines.Add(new Line { Start = interPts[i], End = interPts[i + 1] });
            }

            //SamplePoints adds extra point at start/end. Hence subtracting count here to make sure correct number is extracted.
            List<int> divisions = DistributeDivisions(distributionLines, layout2D.NumberOfPoints - distributionLines.Count);

            List<Point> result = new List<Point>();

            for (int i = 0; i < distributionLines.Count; i++)
            {
                List<Point> divPts = distributionLines[i].SamplePoints(divisions[i]);
                result.AddRange(divPts);
            }
            return result;
        }


        /***************************************************/
        /**** Public Methods - Interface                ****/
        /***************************************************/

        [Description("Queries the points from the Layout based on the layout and a region curve associated with it.")]
        [Input("layout2D", "The layout object to query the points from.")]
        [Input("hostRegionCurve", "The region curve of the objects associated with the layout.")]
        [Output("points", "Point layout generated by the layout objects and region curve.")]
        public static List<Point> IPointLayout(this ILayout2D layout2D, ICurve hostRegionCurve)
        {
            return PointLayout(layout2D as dynamic, hostRegionCurve);
        }

        /***************************************************/
        /**** Private Methods - Fallback                ****/
        /***************************************************/

        private static List<Point> PointLayout(this ILayout2D layout2D, ICurve hostRegionCurve)
        {
            Reflection.Compute.RecordError("PointLayout for " + layout2D.GetType().Name + " is not implemented.");
            return new List<Point>();
        }

        /***************************************************/
        /**** Private Methods                           ****/
        /***************************************************/

        private static List<int> DistributeDivisions(IEnumerable<ICurve> curves, int nbPoints)
        {
            List<ICurve> curveList = curves.ToList();
            List<double> lengths = curves.Select(x => x.ILength()).ToList();
            double fullLength = lengths.Sum();


            List<int> divs = new List<int>();
            List<double> remaining = new List<double>();

            //Check how many division points to extract from each curve, based on length ratio of the curve in relation to the length of all curves
            for (int i = 0; i < curveList.Count; i++)
            {
                double pointRatio = lengths[i] / fullLength * nbPoints;
                int fullCurveDivs = (int)Math.Floor(pointRatio);
                double remainder = pointRatio - fullCurveDivs;

                divs.Add(fullCurveDivs);
                remaining.Add(remainder);
            }

            int remPoints = nbPoints - divs.Sum();

            //Add points to the curve that has the largest reminder after the ratio extraction
            while (remPoints > 0)
            {
                int maxIndex = remaining.IndexOf(remaining.Max());
                divs[maxIndex]++;
                remaining[maxIndex] = 0;
                remPoints--;
            }

            return divs;

        }

        /***************************************************/
    }
}
